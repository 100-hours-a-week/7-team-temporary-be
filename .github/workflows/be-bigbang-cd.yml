

name: BE Production CD (Artifact + Blue-Green + Preflight)

#on:
#  pull_request:
#    types: [closed]
#    branches: [feature/ci-cd]
#  workflow_dispatch:

on:
  push:
    branches:
      - feature/ci-cd

  workflow_dispatch:
    branches:
      - feature/ci-cd

permissions:
  contents: read
  id-token: write

concurrency:
  group: be-prod-cd-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build-artifact:
    name: Build BE Artifact (main)
    runs-on: ubuntu-latest

    if: |
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request.merged == true &&
        github.event.pull_request.base.ref == 'main' &&
        (
          startsWith(github.event.pull_request.head.ref, 'feature/ci-cd')
        )
      )
      ||
      (github.event_name == 'workflow_dispatch')

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up JDK
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "25"

      - name: Grant execute permission for gradlew
        run: chmod +x gradlew

      - name: Cache Gradle
        uses: actions/cache@v4
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper
          key: gradle-${{ runner.os }}-${{ hashFiles('backend/**/*.gradle*', 'backend/**/gradle-wrapper.properties') }}
          restore-keys: |
            gradle-${{ runner.os }}-

      # PR CI에서 테스트가 끝났다는 전제로 -x test
      # 하지만 "아티팩트가 오류나는 코드일까봐" 걱정이면 여기서 test를 다시 돌리면 됨.
      - name: Build (bootJar)
        run: ./gradlew clean bootJar -x test --no-daemon

      - name: Package artifact
        run: |
          set -euo pipefail
          mkdir -p release_bundle
          # bootJar 산출물 찾기 (프로젝트명 달라도 동작)
          JAR="$(ls -1 build/libs/*.jar | head -n 1)"
          [ -f "$JAR" ] || { echo "JAR not found in backend/build/libs"; exit 1; }
          cp "$JAR" release_bundle/app.jar
          # (선택) 배포 메타
          echo "${GITHUB_SHA}" > release_bundle/commit_sha.txt
          tar -czf be-app.tar.gz -C release_bundle .

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: be-app
          path: backend/be-app.tar.gz
          if-no-files-found: error
          retention-days: 7

  deploy-production:
    name: Deploy BE to Production (Blue-Green)
    runs-on: ubuntu-latest
    needs: build-artifact

    #environment:
    #  name: production
  deploy_gcp:
    name: Deploy to GCP (main)
    needs: build-artifact
    runs-on: ubuntu-latest
    #if: github.ref == 'refs/heads/main'
    env:
      GCP_PROJECT: ${{ secrets.GCP_PROJECT_ID }}
      GCP_ZONE: ${{ secrets.GCP_ZONE }}
      GCP_INSTANCE: ${{ secrets.GCE_INSTANCE_NAME }}
      GCP_USER: ${{ secrets.GCE_USER }}
      GCP_TARGET_DIR: ${{ secrets.APP_DIR_AWS }}
      GCP_SERVICE: ${{ secrets.PM2_NAME }}

    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: be-app
          path: .

      - name: Authenticate to GCP
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
          project_id: ${{ secrets.GCP_PROJECT_ID }}


      - name: Setup gcloud
        uses: google-github-actions/setup-gcloud@v2

      - name: Force set active project (critical)
        shell: bash
        run: |
          set -euo pipefail
          gcloud config set project "${GCP_PROJECT}"
          echo "ACTIVE_PROJECT=$(gcloud config get-value project)"
          gcloud config list
          
          #      - name: SSH into VM (public IP) and run simple commands
          #        shell: bash
          #        run: |
          #          set -euo pipefail
          #          gcloud compute ssh "${GCP_INSTANCE}" \
          #            --project "${GCP_PROJECT}" \
          #            --zone "${GCP_ZONE}" \
          #            --quiet \
          #            --command "echo 'SSH_OK'; whoami; hostname; uname -a"
      

      # 1) tar 업로드  2) 원격에서 preflight + blue/green + switch
      # 파일이동만 처리
      - name: Upload artifact (GCP scp)
        run: |
          set -euo pipefail

          gcloud compute scp be-app.tar.gz \
            ${GCP_USER}@${GCP_INSTANCE}:/tmp/be-app.tar.gz \
            --zone="${GCP_ZONE}" \
            --project="${GCP_PROJECT}" \
            --quiet

      # ssh 접속
      - name: Deploy (remote script)
        run: |
               set -euo pipefail
               gcloud compute ssh ${GCP_USER}@${GCP_INSTANCE} \
               --zone "${GCP_ZONE}" \
               --project "${GCP_PROJECT}" \
               --quiet \
               --command "bash -se" <<'EOSSH'
               
               set -euo pipefail
               
               APP_DIR="${{ secrets.APP_DIR }}"        # home/ubuntu/be
               RELEASE_DIR="${APP_DIR}/releases"
               CURRENT_DIR="${APP_DIR}/current"
               
               BLUE_PORT="${{ secrets.BLUE_PORT }}"      # 8080
               GREEN_PORT="${{ secrets.GREEN_PORT }}"    # 8081
               PM2_BLUE="${{ secrets.PM2_BLUE_NAME }}"   # molip-be-blue
               PM2_GREEN="${{ secrets.PM2_GREEN_NAME }}" # molip-be-green
               
               HEALTH_BLUE="${{ secrets.HEALTH_BLUE_URL }}"   # healthurl:8080
               HEALTH_GREEN="${{ secrets.HEALTH_GREEN_URL }}" # health:8081
               
               UPSTREAM_CONF="${{ secrets.NGINX_UPSTREAM_CONF }}" #  /etc/nginx/sites-available/molip
               
               # PREFLIGHT 상수 (필요하면 조정)
               MIN_MEM=1843200
               MAX_LA=1.0
               DISK_MIN_REM=3
               
               # (선택) DB preflight를 쓰려면 mysql client가 서버에 있어야 함
               DB_HOST="${{ secrets.DB_HOST }}"  # localhost
               DB_PORT="${{ secrets.DB_PORT }}"  # 3306
               DB_USER="${{ secrets.DB_USER }}"  # molip
               DB_PASS="${{ secrets.DB_PASS }}"  # molip1234
               DB_MAX_CONN="${{ secrets.DB_MAX_CONNECTIONS }}"  # 151             
               GREEN_POOL="${{ secrets.GREEN_DB_POOL }}" # 10
               
               echo "== [1] Preflight: MemAvailable =="
               MEM_AVAIL=$(grep '^MemAvailable:' /proc/meminfo | awk '{print $2}')
               [ "${MEM_AVAIL}" -ge "${MIN_MEM}" ] || { echo "FAIL: MEM 부족 (${MEM_AVAIL} < ${MIN_MEM})"; exit 1; }
               
               echo "== [2] Preflight: LoadAvg =="
               LA1=$(awk '{print $1}' /proc/loadavg)
               LA5=$(awk '{print $2}' /proc/loadavg)
               awk -v la1="$LA1" -v la5="$LA5" -v max="$MAX_LA" 'BEGIN { exit ! (la1 <= max && la5 <= max) }' \
                || { echo "FAIL: LA1=${LA1}, LA5=${LA5} > ${MAX_LA}"; exit 1; }
               
               echo "== [3] Preflight: Disk Free =="
               FREE_GB=$(df -BG / | awk 'NR==2 {gsub(/G/,"",$4); print $4}')
               [ "${FREE_GB}" -ge "${DISK_MIN_REM}" ] || { echo "FAIL: 디스크 부족 (${FREE_GB}G < ${DISK_MIN_REM}G)"; exit 1; }
               
               echo "== [4] Preflight: DB Connections (optional) =="
               if command -v mysql >/dev/null 2>&1; then
                CUR_CONN=$(MYSQL_PWD="${DB_PASS}" mysql -h "${DB_HOST}" -P "${DB_PORT}" -u "${DB_USER}" \
                  -Nse "SHOW STATUS LIKE 'Threads_connected';" 2>/dev/null | awk '{print $2}')
                CUR_CONN="${CUR_CONN:-0}"
                MAX_CONN="${DB_MAX_CONN}"
                THRESH_CONN=$(( MAX_CONN * 60 / 100 ))
                REMAIN_CONN=$(( MAX_CONN - CUR_CONN ))
               
                [ "${CUR_CONN}" -le "${THRESH_CONN}" ] || { echo "FAIL: DB 연결 과다 ${CUR_CONN} > ${THRESH_CONN}"; exit 1; }
                [ "${REMAIN_CONN}" -ge "${GREEN_POOL}" ] || { echo "FAIL: 남은 커넥션 부족 ${REMAIN_CONN} < ${GREEN_POOL}"; exit 1; }
               else
                echo "mysql client not found -> DB preflight skipped"
               fi
               
               echo "== Extract artifact =="
               mkdir -p "${RELEASE_DIR}"
               TS="$(date +%Y%m%d%H%M%S)"
               NEW_REL="${RELEASE_DIR}/${TS}"
               mkdir -p "${NEW_REL}"
               tar -xzf /tmp/be-app.tar.gz -C "${NEW_REL}"
               [ -f "${NEW_REL}/app.jar" ] || { echo "FAIL: app.jar not found"; exit 1; }
               ln -sfn "${NEW_REL}" "${CURRENT_DIR}"
               
               echo "== Detect ACTIVE port from Nginx upstream =="
               ACTIVE_PORT=$(grep -Eo '127\.0\.0\.1:[0-9]+' "${UPSTREAM_CONF}" | head -n 1 | cut -d: -f2)
               
               if [ "${ACTIVE_PORT}" = "${BLUE_PORT}" ]; then
                ACTIVE_PM2="${PM2_BLUE}"
                IDLE_PM2="${PM2_GREEN}"
                IDLE_PORT="${GREEN_PORT}"
                IDLE_HEALTH="${HEALTH_GREEN}"
               else
                ACTIVE_PM2="${PM2_GREEN}"
                IDLE_PM2="${PM2_BLUE}"
                IDLE_PORT="${BLUE_PORT}"
                IDLE_HEALTH="${HEALTH_BLUE}"
               fi
               
               echo "ACTIVE_PM2=${ACTIVE_PM2} (port=${ACTIVE_PORT})"
               echo "IDLE_PM2=${IDLE_PM2} (port=${IDLE_PORT})"

                # 배포
               echo "== Start IDLE process =="
               sudo pm2 delete "${IDLE_PM2}" >/dev/null 2>&1 || true
               sudo pm2 start "${ECOSYSTEM}" --only "${IDLE_PM2}" --env production
               
               echo "== Health check IDLE (max 60s) =="
               for i in {1..30}; do
               if curl -fsS "${IDLE_HEALTH}" >/dev/null; then
               echo "Health OK"
               break
               fi
               sleep 2
               done
               curl -fsS "${IDLE_HEALTH}" >/dev/null || {
               echo "FAIL: Health check";
               exit 1;
                }
               
               echo "== Switch Nginx upstream -> ${IDLE_PORT} =="
               sudo sed -i -E "0,/127\\.0\\.0\\.1:[0-9]+/s//127.0.0.1:${IDLE_PORT}/" "${UPSTREAM_CONF}"
               sudo nginx -t
               sudo systemctl reload nginx || sudo nginx -s reload
               
               echo "== Verify after switch =="
               if ! curl -fsS "${IDLE_HEALTH}" >/dev/null; then
               echo "FAIL: Post-switch health -> rollback upstream"
               sudo sed -i -E "0,/127\\.0\\.0\\.1:[0-9]+/s//127.0.0.1:${ACTIVE_PORT}/" "${UPSTREAM_CONF}"
               sudo nginx -t
               sudo systemctl reload nginx || sudo nginx -s reload
               exit 1
               fi

               echo "== Stop OLD process: ${ACTIVE_PM2} =="
               pm2 delete "${ACTIVE_PM2}" >/dev/null 2>&1 || true
               pm2 save >/dev/null 2>&1 || true
               
               echo "== DEPLOY SUCCESS =="
               EOSSH
